# YalcoPattern2
얄코패턴 시즌2
- 얄코노션 : yalco.kr/notion
- 소스위치 : https://yalco.notion.site/OODP-Example-Codes-Materials-65ec117a777b46b2b8c732d8188fd94e
### Creational Patterns
- Factory Method
- Abstract Factory
- Builder
- Prototype
- Singleton

### Structural Patterns
- Adapter
- Bridge
- Composite
- Decorator
- Facade
- Flyweight
- Proxy

### Behavioral Patterns
- Chain of Responsibility
- Command
- Interpreter
- Mediator
- Memento
- Observer
- Publisher-Subscriber
- State
- Strategy
- Template Method
- Visitor
- Specification
- Iterator

## Factory Method 패턴이 유용한 경우

- **객체 생성 방식을 서브클래스에 위임하고 싶을 때**
  - 상위 클래스에서 객체 생성의 뼈대를 정의하고, 실제 생성은 하위 클래스에서 결정하도록 할 수 있습니다.
- **코드에서 구체적인 객체 타입을 명시하지 않고 싶을 때**
  - 클라이언트 코드가 구체적인 클래스에 의존하지 않고, 인터페이스나 추상 클래스에만 의존하도록 할 수 있습니다.
- **객체 생성 로직이 자주 변경되거나 확장될 때**
  - 새로운 타입의 객체가 추가되어도 기존 코드를 수정하지 않고 확장할 수 있습니다.

---

### 예시

- **UI 프레임워크에서 OS별 버튼/윈도우 생성**
- **문서 편집기에서 다양한 문서 타입 생성**
- **게임에서 다양한 몬스터/아이템 생성**

---

### 장점

- 객체 생성 코드의 중복 제거 및 관리 용이
- 새로운 제품(객체) 추가 시 기존 코드 수정 최소화(개방-폐쇄 원칙)
- 클라이언트와 구체 클래스의 결합도 감소

---

### 단점

- 클래스 수가 많아질 수 있음
- 단순한 경우에는 구조가 복잡해질 수 있음

---

**요약:**  
Factory Method 패턴은 객체 생성 방식을 서브클래스에 위임해, 확장성과 유연성을 높이고, 구체 클래스와의 결합도를 낮추고 싶을 때 유용합니다.

## Abstract Factory 패턴이 유용한 경우

- **관련된 객체들의 집합을 일관성 있게 생성해야 할 때**
  - 서로 관련된 여러 객체(제품군)를 함께 생성해야 하며, 이들 간의 호환성을 보장하고 싶을 때 유용합니다.
- **구체적인 클래스에 의존하지 않고, 제품군을 교체해야 할 때**
  - 클라이언트 코드가 구체적인 클래스가 아닌 인터페이스/추상 클래스에만 의존하도록 하여, 제품군 전체를 쉽게 교체할 수 있습니다.
- **플랫폼(운영체제, DB 등)에 따라 다양한 구현체를 제공해야 할 때**
  - 예: Windows/MacOS/Linux 등 다양한 환경에 맞는 UI 컴포넌트 제공

---

### 예시

- **UI 툴킷에서 OS별 위젯(버튼, 체크박스 등) 생성**
- **DB 커넥션, DAO 등 제품군을 환경에 따라 교체**
- **게임에서 테마별(스킨별) 아이템/캐릭터 생성**

---

### 장점

- 제품군 간의 일관성 보장
- 제품군 전체 교체가 쉬움(확장성, 유연성)
- 구체 클래스와의 결합도 감소

---

### 단점

- 새로운 제품(객체) 추가가 어려울 수 있음(제품군에는 쉬움, 제품에는 어려움)
- 구조가 복잡해질 수 있음

---

**요약:**  
Abstract Factory 패턴은 관련된 객체 집합(제품군)을 일관성 있게 생성하고, 제품군 전체를 쉽게 교체하거나 다양한 환경에 맞는 구현체를 제공할 때 유용합니다.

## Builder 패턴이 유용한 경우

- **복잡한 객체(여러 단계, 다양한 옵션)의 생성 과정을 단순화하고 싶을 때**
  - 생성 과정이 복잡하거나, 다양한 조합의 옵션이 있는 객체를 단계별로 유연하게 생성할 수 있습니다.
- **동일한 생성 절차로 서로 다른 표현(구성)의 객체를 만들고 싶을 때**
  - 같은 빌더 인터페이스로 다양한 결과물을 만들 수 있습니다.
- **객체 생성 코드와 표현(구성) 코드를 분리하고 싶을 때**
  - 생성 로직과 객체의 표현을 분리해, 유지보수성과 확장성을 높일 수 있습니다.

---

### 예시

- **복잡한 문서, HTML/XML, SQL 쿼리 생성**
- **자동차, 컴퓨터 등 부품 조합이 다양한 제품 생성**
- **게임 캐릭터, 맵 등 단계별로 설정이 필요한 객체 생성**

---

### 장점

- 복잡한 객체 생성 과정을 단계별로 관리 가능
- 다양한 옵션/조합의 객체 생성이 쉬움
- 생성 코드와 표현 코드의 분리로 유지보수성 향상

---

### 단점

- 단순한 객체에는 오히려 구조가 복잡해질 수 있음
- 빌더 클래스가 많아질 수 있음

---

**요약:**  
Builder 패턴은 복잡하거나 다양한 옵션을 가진 객체를 단계별로 유연하게 생성하고, 생성 과정과 표현을 분리하고 싶을 때 유용합니다.

## Prototype 패턴이 유용한 경우

- **복잡한 객체를 새로 생성하는 비용이 크거나, 생성 과정이 복잡할 때**
  - 기존 객체를 복제(clone)하여 새로운 객체를 빠르게 만들고 싶을 때 유용합니다.
- **런타임에 객체의 복사본이 자주 필요할 때**
  - 동적으로 객체를 복제해 다양한 상태의 인스턴스를 쉽게 만들 수 있습니다.
- **객체의 구조나 타입이 동적으로 결정될 때**
  - 팩토리나 생성자 대신, 프로토타입 객체를 복제해 새로운 객체를 생성할 수 있습니다.

---

### 예시

- **그래픽 에디터에서 도형 복제**
- **게임에서 몬스터, 아이템 등 다양한 상태의 객체 복제**
- **설정/환경 객체의 복사본 생성**

---

### 장점

- 객체 생성 비용 절감(복잡한 초기화 과정 생략)
- 런타임에 동적으로 객체 생성 가능
- 객체의 상태를 그대로 복제 가능

---

### 단점

- 깊은 복사(Deep Copy) 구현이 복잡할 수 있음
- 복제된 객체의 상태 관리에 주의 필요

---

**요약:**  
Prototype 패턴은 복잡하거나 생성 비용이 큰 객체를 빠르게 복제해 사용하고 싶을 때, 또는 런타임에 다양한 상태의 객체가 자주 필요할 때 유용합니다.

## Singleton 패턴이 유용한 경우

- **애플리케이션 전체에서 단 하나의 인스턴스만 필요할 때**
  - 전역적으로 하나만 존재해야 하는 객체(설정, 로거, 캐시 등)를 보장하고 싶을 때 유용합니다.
- **공유 자원(설정, DB 연결 등)을 여러 곳에서 사용해야 할 때**
  - 여러 객체가 동일한 인스턴스를 공유해야 할 때 사용합니다.
- **인스턴스 생성 비용이 크거나, 상태를 일관되게 유지해야 할 때**
  - 불필요한 객체 생성을 방지하고, 상태를 일관성 있게 관리할 수 있습니다.

---

### 예시

- **설정(환경설정) 객체**
- **로깅(Logging) 객체**
- **DB 커넥션 풀, 캐시 등 공유 자원**

---

### 장점

- 인스턴스가 하나임을 보장(전역 접근)
- 자원 절약 및 상태 일관성 유지

---

### 단점

- 테스트가 어려울 수 있음(글로벌 상태)
- 의존성 주입 등과 충돌 가능성
- 멀티스레드 환경에서 동기화 주의 필요

---

**요약:**  
Singleton 패턴은 애플리케이션 전체에서 단 하나의 인스턴스만 필요하고, 전역적으로 공유해야 할 때 유용합니다.

## Adapter 패턴이 유용한 경우

- **호환되지 않는 인터페이스를 가진 클래스를 함께 사용해야 할 때**
  - 기존 코드(클래스)와 새 코드(클래스)의 인터페이스가 달라 바로 사용할 수 없을 때, 중간에 어댑터를 두어 호환시킬 수 있습니다.
- **라이브러리, 레거시 코드 등 외부 코드와의 통합이 필요할 때**
  - 외부 라이브러리나 레거시 시스템의 인터페이스를 변경하지 않고, 현재 시스템에 맞게 사용할 수 있습니다.
- **클래스 재사용성을 높이고 싶을 때**
  - 기존 클래스를 수정하지 않고, 다양한 환경에서 재사용할 수 있습니다.

---

### 예시

- **전원 어댑터(220V → 110V 변환 등)**
- **레거시 시스템과의 연동**
- **서로 다른 인터페이스를 가진 API 통합**

---

### 장점

- 기존 코드 수정 없이 재사용 가능
- 인터페이스 호환성 확보
- 외부/레거시 코드와의 통합 용이

---

### 단점

- 코드가 복잡해질 수 있음(어댑터 남용 시)
- 새로운 인터페이스가 추가되면 어댑터도 추가 구현 필요

---

**요약:**  
Adapter 패턴은 호환되지 않는 인터페이스를 가진 클래스나 외부/레거시 코드를 현재 시스템에 맞게 통합하고 싶을 때 유용합니다.

## Bridge 패턴이 유용한 경우

- **추상화(Abstraction)와 구현(Implementation)을 분리해 독립적으로 확장하고 싶을 때**
  - 기능 계층과 구현 계층을 분리해, 각각을 독립적으로 변경/확장할 수 있습니다.
- **클래스 계층 구조가 조합에 따라 급격히 증가할 때(클래스 폭발 문제)**
  - 예: 기능 X 구현의 조합이 많아질 때, 상속 대신 브리지로 조합을 유연하게 관리할 수 있습니다.
- **런타임에 구현체를 바꿔야 할 때**
  - 추상화와 구현을 분리해, 실행 중에도 구현체를 동적으로 교체할 수 있습니다.

---

### 예시

- **UI 시스템에서 다양한 OS별 렌더러와 위젯 조합**
- **그래픽 라이브러리에서 도형(추상화)과 그리기 API(구현) 분리**
- **리모컨(추상화)과 다양한 TV(구현) 조합**

---

### 장점

- 추상화와 구현의 독립적 확장 가능
- 클래스 수 감소(조합의 유연성)
- 런타임에 구현체 교체 가능

---

### 단점

- 구조가 복잡해질 수 있음(분리로 인한 계층 증가)

---

**요약:**  
Bridge 패턴은 추상화와 구현을 분리해 각각을 독립적으로 확장하고, 조합의 유연성을 높이고 싶을 때 유용합니다.

## Composite 패턴이 유용한 경우

- **부분-전체(트리) 구조를 동일한 방식으로 다루고 싶을 때**
  - 객체들을 트리 구조(계층 구조)로 구성하고, 개별 객체와 복합 객체(그룹)를 동일하게 다루고 싶을 때 유용합니다.
- **클라이언트가 단일 객체와 복합 객체를 구분하지 않고 사용해야 할 때**
  - 단일 객체와 복합 객체에 동일한 인터페이스를 제공해, 클라이언트 코드가 일관되게 동작할 수 있습니다.
- **재귀적 구조(폴더, 조직도 등)를 구현할 때**
  - 폴더-파일, 조직도, UI 컴포넌트 등 계층적 구조를 재귀적으로 표현할 때 적합합니다.

---

### 예시

- **파일 시스템(폴더-파일 구조)**
- **조직도, 트리 구조 데이터**
- **UI 컴포넌트(컨테이너-위젯 구조)**

---

### 장점

- 단일 객체와 복합 객체를 일관되게 처리 가능
- 트리 구조의 유연한 관리 및 확장
- 클라이언트 코드 단순화

---

### 단점

- 설계가 복잡해질 수 있음(트리 구조 관리)
- 너무 일반화하면 타입 안전성이 떨어질 수 있음

---

**요약:**  
Composite 패턴은 트리 구조(부분-전체)를 동일한 방식으로 다루고, 단일/복합 객체를 일관되게 처리하고 싶을 때 유용합니다.

## Decorator 패턴이 유용한 경우

- **객체에 동적으로 새로운 기능(책임)을 추가하고 싶을 때**
  - 상속 없이 런타임에 객체의 기능을 유연하게 확장할 수 있습니다.
- **여러 기능(책임)을 조합해 다양한 객체를 만들고 싶을 때**
  - 다양한 데코레이터를 조합해, 기능의 조합을 유연하게 관리할 수 있습니다.
- **기존 코드(클래스)를 수정하지 않고 기능을 확장하고 싶을 때**
  - OCP(개방-폐쇄 원칙)를 지키면서 기능을 추가할 수 있습니다.

---

### 예시

- **입력/출력 스트림에 버퍼, 암호화, 압축 등 기능 추가**
- **UI 컴포넌트에 스크롤, 테두리, 그림자 등 추가**
- **로깅, 권한 검사 등 부가 기능 동적 추가**

---

### 장점

- 상속 없이 기능 확장 가능(유연성)
- 기능의 조합이 자유로움
- 기존 코드 수정 없이 기능 추가 가능

---

### 단점

- 데코레이터가 많아지면 구조가 복잡해질 수 있음
- 디버깅이 어려울 수 있음(중첩 구조)

---

**요약:**  
Decorator 패턴은 객체에 동적으로 다양한 기능을 조합해 확장하고 싶을 때, 상속 대신 유연하게 기능을 추가하고 싶을 때 유용합니다.

## Facade 패턴이 유용한 경우

- **복잡한 서브시스템(여러 클래스, 모듈 등)을 단순한 인터페이스로 감싸고 싶을 때**
  - 여러 객체나 라이브러리의 복잡한 사용법을 하나의 간단한 인터페이스로 제공하고 싶을 때 유용합니다.
- **클라이언트가 서브시스템의 내부 구조를 몰라도 되게 하고 싶을 때**
  - 클라이언트는 퍼사드만 사용하고, 내부 구현은 숨길 수 있습니다.
- **서브시스템의 결합도를 낮추고 싶을 때**
  - 클라이언트와 서브시스템 간의 의존성을 줄여, 유지보수성과 확장성을 높일 수 있습니다.

---

### 예시

- **복잡한 라이브러리/프레임워크 초기화, 종료, 사용 등 단순화**
- **여러 하위 시스템(파일, 네트워크, DB 등) 통합 인터페이스 제공**
- **가전제품 리모컨(여러 기능을 하나의 버튼으로 제어)**

---

### 장점

- 복잡한 시스템을 단순하게 사용할 수 있음
- 클라이언트와 서브시스템의 결합도 감소
- 유지보수 및 확장 용이

---

### 단점

- 퍼사드에 너무 많은 책임이 집중될 수 있음
- 서브시스템의 모든 기능을 노출하지 못할 수 있음

---

**요약:**  
Facade 패턴은 복잡한 서브시스템을 단순한 인터페이스로 감싸 클라이언트가 쉽게 사용하도록 하고, 결합도를 낮추고 싶을 때 유용합니다.

## Flyweight 패턴이 유용한 경우

- **대량의 유사 객체를 효율적으로 관리하고 싶을 때**
  - 동일하거나 비슷한 객체가 매우 많이 필요할 때, 공통된 상태를 공유해 메모리 사용을 최소화할 수 있습니다.
- **객체의 공유가 가능하고, 불변(변하지 않는) 상태가 많을 때**
  - 내부 상태(공유 가능)는 Flyweight로, 외부 상태(개별적)는 별도로 관리해 효율을 높입니다.
- **메모리 사용량이 중요한 시스템(게임, 그래픽, 텍스트 편집 등)에서**
  - 수많은 객체(문자, 아이콘, 타일 등)를 효율적으로 관리할 때 적합합니다.

---

### 예시

- **문자열/문자 렌더링(폰트 글리프 공유)**
- **게임의 타일, 총알, 파티클 등 대량 객체 관리**
- **아이콘, 이미지 등 반복 사용되는 리소스 공유**

---

### 장점

- 메모리 사용량 대폭 절감
- 대량 객체의 효율적 관리

---

### 단점

- 코드가 복잡해질 수 있음(상태 분리 필요)
- 외부 상태 관리에 주의 필요

---

**요약:**  
Flyweight 패턴은 대량의 유사 객체를 메모리 효율적으로 관리하고, 공유 가능한 상태를 최대한 재사용하고 싶을 때 유용합니다.

## Proxy 패턴이 유용한 경우

- **접근 제어나 부가 기능(로깅, 캐싱 등)이 필요한 객체 앞에 대리 객체를 두고 싶을 때**
  - 실제 객체에 직접 접근하지 않고, 프록시를 통해 접근을 제어하거나 부가 기능을 추가할 수 있습니다.
- **리소스가 무겁거나, 객체 생성을 지연(지연 로딩)하고 싶을 때**
  - 실제 객체의 생성을 늦추거나, 필요할 때만 생성해 성능을 최적화할 수 있습니다.
- **원격 객체, 보안, 캐싱 등 다양한 상황에서 대리 객체가 필요할 때**
  - 네트워크 통신, 접근 권한, 결과 캐싱 등 다양한 용도로 활용할 수 있습니다.

---

### 예시

- **가상 프록시(지연 로딩): 이미지, 대용량 데이터 등 필요할 때만 로딩**
- **보호 프록시: 접근 권한 제어**
- **원격 프록시: 네트워크를 통한 객체 접근**
- **캐싱 프록시: 결과를 캐싱해 성능 향상**

---

### 장점

- 접근 제어, 로깅, 캐싱 등 부가 기능 추가 용이
- 실제 객체의 생성을 지연하거나, 자원 관리 최적화
- 클라이언트와 실제 객체의 결합도 감소

---

### 단점

- 구조가 복잡해질 수 있음(프록시 남용 시)
- 프록시와 실제 객체의 동기화에 주의 필요

---

**요약:**  
Proxy 패턴은 접근 제어, 로깅, 캐싱, 지연 로딩 등 다양한 부가 기능을 실제 객체 앞에 대리 객체로 유연하게 추가하고 싶을 때 유용합니다.

## Chain of Responsibility 패턴이 유용한 경우

- **여러 객체가 특정 요청을 처리할 수 있을 때**
  - 요청을 처리할 수 있는 객체가 여러 개 존재하고, 그 중 하나가 처리해야 할 때 유용합니다.
- **요청 처리자를 코드에서 명시적으로 지정하지 않고 싶을 때**
  - 클라이언트가 어떤 객체가 요청을 처리할지 알 필요 없이, 처리 책임을 동적으로 연결된 객체들 사이에서 전달할 수 있습니다.
- **요청 처리 로직을 유연하게 변경하고 싶을 때**
  - 핸들러의 순서나 구성을 동적으로 바꿀 수 있어, 새로운 핸들러 추가/제거가 쉽습니다.
- **결합도를 낮추고 싶을 때**
  - 요청을 보내는 쪽과 처리하는 쪽의 결합도를 낮춰, 시스템의 유연성과 확장성을 높일 수 있습니다.

---

### 예시

- **로그 처리**: 로그 레벨(Info, Debug, Error 등)에 따라 서로 다른 핸들러가 처리
- **이벤트 처리**: GUI 이벤트가 여러 컴포넌트에 의해 처리될 수 있을 때
- **권한 검증**: 여러 단계의 권한 검증이 필요한 경우(예: 인증 → 권한 → 데이터 검증 등)

---

### 장점

- 객체 간 결합도 감소
- 새로운 핸들러 추가/제거가 용이
- 처리 순서의 유연한 변경 가능

---

### 단점

- 요청이 끝까지 전달될 때까지 처리자가 없으면 무시될 수 있음
- 디버깅이 어려울 수 있음(어디서 처리됐는지 추적이 어려움)

---

**요약:**  
Chain of Responsibility 패턴은 요청을 처리할 수 있는 객체가 여러 개이고, 그 중 하나가 처리해야 하며, 처리 순서나 구성을 유연하게 바꿔야 할 때 매우 유용합니다.

## Command 패턴이 유용한 경우

- **요청(명령)을 객체로 캡슐화하고 싶을 때**
  - 실행할 동작(명령)을 객체로 만들어, 매개변수로 전달하거나 큐에 저장, 로그로 남길 수 있습니다.
- **실행 취소(Undo), 재실행(Redo) 기능이 필요할 때**
  - 명령 객체에 실행/취소 메서드를 정의해, 작업의 취소와 재실행을 쉽게 구현할 수 있습니다.
- **요청의 실행 시점과 요청자/수행자를 분리하고 싶을 때**
  - 명령을 요청하는 객체와 실제로 명령을 수행하는 객체를 분리해, 결합도를 낮출 수 있습니다.
- **작업의 기록, 트랜잭션, 매크로 기능이 필요할 때**
  - 명령 객체를 모아 일괄 실행하거나, 작업 내역을 기록해 트랜잭션/매크로 기능을 구현할 수 있습니다.

---

### 예시

- **GUI 버튼/메뉴의 동작**: 버튼 클릭 시 실행할 동작을 명령 객체로 캡슐화
- **실행 취소/재실행**: 텍스트 에디터 등에서 작업의 Undo/Redo 구현
- **작업 큐/스케줄러**: 명령을 큐에 저장해 순차적으로 실행

---

### 장점

- 명령, 요청, 실행의 분리로 결합도 감소
- 실행 취소/재실행, 매크로 등 다양한 기능 확장 용이
- 새로운 명령 추가가 쉬움

---

### 단점

- 명령 객체가 많아질 수 있어 관리가 복잡해질 수 있음

---

**요약:**  
Command 패턴은 요청을 객체로 캡슐화해 실행 시점, 실행자, 요청자를 분리하고, Undo/Redo, 매크로, 작업 기록 등 다양한 기능을 유연하게 구현할 때 유용합니다.

## Interpreter 패턴이 유용한 경우

- **문법(언어) 규칙을 객체로 표현하고 싶을 때**
  - 간단한 언어나 표현식의 문법을 클래스 구조로 표현하여, 해석(interpret) 기능을 객체로 구현할 수 있습니다.
- **자주 변경되거나 확장 가능한 문법이 필요할 때**
  - 새로운 문법 규칙을 쉽게 추가하거나 수정할 수 있습니다.
- **간단한 DSL(Domain Specific Language)이나 수식 계산기, 필터, 검색 쿼리 등 구현 시**
  - 복잡하지 않은 언어의 해석기, 계산기, 필터링 시스템 등에 적합합니다.

---

### 예시

- **수식 계산기**: 사칙연산, 괄호 등으로 구성된 수식 해석
- **간단한 SQL/검색 쿼리 해석**: WHERE, SELECT 등 간단한 쿼리 언어 해석
- **DSL(도메인 특화 언어) 해석**: 특정 도메인에 특화된 간단한 언어 해석

---

### 장점

- 문법 규칙의 구조화 및 재사용 용이
- 새로운 문법 추가/수정이 쉬움
- 복잡한 해석 로직을 객체로 분리 가능

---

### 단점

- 복잡한 문법(언어)에는 클래스 수가 급격히 증가해 비효율적
- 성능이 중요한 대규모 언어 해석에는 부적합

---

**요약:**  
Interpreter 패턴은 간단한 언어나 표현식의 문법을 객체로 구조화하여 해석할 때, 그리고 문법의 확장/수정이 자주 필요한 경우에 유용합니다.

## Mediator 패턴이 유용한 경우

- **여러 객체(컴포넌트) 간의 복잡한 상호작용을 중앙에서 관리하고 싶을 때**
  - 객체들이 직접 서로를 참조하지 않고, 중재자(Mediator)를 통해 통신하도록 하여 결합도를 낮출 수 있습니다.
- **객체 간의 의존성을 줄이고 싶을 때**
  - 각 객체가 중재자만 알면 되므로, 객체 간의 의존성이 줄어듭니다.
- **객체 간 상호작용이 자주 변경되거나 확장될 때**
  - 상호작용 로직을 중재자에 집중시켜, 변경이 쉬워집니다.

---

### 예시

- **UI 컴포넌트 간 상호작용**: 버튼, 텍스트박스, 리스트 등 여러 UI 요소가 서로 영향을 줄 때
- **채팅방 시스템**: 여러 사용자가 중재자(채팅방)를 통해 메시지를 주고받을 때
- **항공 교통 관제**: 여러 비행기가 관제탑(중재자)을 통해 소통할 때

---

### 장점

- 객체 간 결합도 감소, 유지보수성 향상
- 상호작용 로직의 중앙 집중화로 관리 용이
- 새로운 컴포넌트 추가/변경이 쉬움

---

### 단점

- 중재자(Mediator)가 복잡해질 수 있음(로직 집중)

---

**요약:**  
Mediator 패턴은 여러 객체 간의 복잡한 상호작용을 중앙에서 관리하고, 결합도를 낮추며, 상호작용의 변경/확장이 자주 필요한 경우에 유용합니다.

## Memento 패턴이 유용한 경우

- **객체의 상태를 이전으로 되돌릴 필요가 있을 때**
  - 실행 취소(Undo), 복원(Redo) 등 기능을 구현할 때 객체의 상태를 저장하고 복원할 수 있습니다.
- **캡슐화를 유지하면서 객체의 상태를 외부에 저장하고 싶을 때**
  - 객체의 내부 상태를 외부에 노출하지 않고, 안전하게 저장/복원할 수 있습니다.
- **상태 이력을 관리해야 할 때**
  - 여러 시점의 상태를 저장해 두고, 필요할 때 특정 시점으로 복원할 수 있습니다.

---

### 예시

- **텍스트 에디터의 실행 취소/재실행(Undo/Redo)**
- **게임의 저장/불러오기(세이브/로드)**
- **설정 변경의 롤백**

---

### 장점

- 캡슐화 위반 없이 객체 상태 저장/복원 가능
- 실행 취소, 재실행 등 다양한 기능 구현 용이

---

### 단점

- 저장하는 상태가 많아지면 메모리 사용량 증가
- 관리할 상태가 복잡할 경우 구현이 어려울 수 있음

---

**요약:**  
Memento 패턴은 객체의 상태를 캡슐화하여 저장/복원하고, Undo/Redo, 롤백, 세이브/로드 등 상태 복원이 필요한 기능에 유용합니다.

## Observer 패턴이 유용한 경우

- **한 객체의 상태 변화가 여러 객체에 자동으로 전파되어야 할 때**
  - 주체(Subject)의 상태가 바뀔 때, 여러 관찰자(Observer)에게 자동으로 알림을 보내고 싶을 때 유용합니다.
- **객체 간의 느슨한 결합이 필요할 때**
  - 주체와 관찰자가 서로를 직접 참조하지 않고, 인터페이스를 통해 느슨하게 연결할 수 있습니다.
- **이벤트 기반 시스템, 데이터 바인딩 등 다양한 알림 구조가 필요할 때**
  - GUI, 실시간 데이터, 알림 시스템 등에서 활용됩니다.

---

### 예시

- **GUI 이벤트 처리(버튼 클릭 등)**
- **모델-뷰(Model-View) 구조에서 데이터 변경 알림**
- **뉴스 구독, 알림 시스템 등**

---

### 장점

- 객체 간 결합도 감소(확장성, 재사용성 향상)
- 동적으로 관찰자 추가/제거 가능
- 다양한 알림 구조 구현 가능

---

### 단점

- 관찰자 수가 많아지면 성능 저하 가능
- 복잡한 알림 체계는 디버깅이 어려울 수 있음

---

**요약:**  
Observer 패턴은 한 객체의 상태 변화가 여러 객체에 자동으로 전파되어야 하거나, 이벤트 기반 알림 구조가 필요할 때 유용합니다.

## Publisher-Subscriber 패턴이 유용한 경우

- **발행자(Publisher)와 구독자(Subscriber)가 서로 직접 알 필요 없이, 메시지/이벤트를 비동기적으로 전달하고 싶을 때**
  - 발행자와 구독자가 느슨하게 결합되어, 서로 독립적으로 동작할 수 있습니다.
- **여러 구독자가 특정 이벤트/메시지를 받아야 할 때**
  - 한 번의 발행으로 여러 구독자에게 동시에 알림을 보낼 수 있습니다.
- **이벤트 기반 시스템, 메시지 브로커, 비동기 통신 등에서 활용할 때**
  - 대규모 시스템, 분산 시스템, 실시간 알림 등에서 자주 사용됩니다.

---

### 예시

- **이메일/뉴스레터 구독 시스템**
- **메시지 큐, 이벤트 버스, 브로커 기반 아키텍처**
- **실시간 알림, 채팅, 스트리밍 서비스 등**

---

### 장점

- 발행자와 구독자의 결합도 감소(확장성, 유연성 향상)
- 비동기 처리 및 대규모 분산 시스템에 적합
- 구독자 동적 추가/제거 용이

---

### 단점

- 디버깅 및 추적이 어려울 수 있음
- 메시지 순서, 중복 처리 등 관리 필요

---

**요약:**  
Publisher-Subscriber 패턴은 발행자와 구독자가 직접 연결되지 않고, 메시지/이벤트를 비동기적으로 전달해야 하는 대규모, 분산, 실시간 시스템에 유용합니다.

## State 패턴이 유용한 경우

- **객체의 상태에 따라 동작(행동)이 달라져야 할 때**
  - 객체가 여러 상태를 가질 수 있고, 상태에 따라 메서드의 동작이 달라져야 할 때 유용합니다.
- **상태 전환이 자주 일어나고, 상태별 행동이 복잡할 때**
  - if-else, switch문 대신 각 상태를 클래스로 분리해 관리할 수 있습니다.
- **상태별 행동을 캡슐화해, 코드의 가독성과 유지보수성을 높이고 싶을 때**
  - 상태별 클래스를 만들어, 상태 전환과 행동을 명확하게 분리할 수 있습니다.

---

### 예시

- **문서 편집기의 상태(편집/읽기/잠금 등)에 따른 동작**
- **게임 캐릭터의 상태(이동/점프/공격 등)에 따른 행동**
- **네트워크 연결(연결됨/끊김/재연결 등) 상태 관리**

---

### 장점

- 상태별 행동을 명확하게 분리(가독성, 유지보수성 향상)
- 상태 추가/변경이 쉬움(확장성)
- 조건문(if-else, switch) 제거로 코드 단순화

---

### 단점

- 상태 클래스가 많아질 수 있음
- 단순한 경우에는 구조가 복잡해질 수 있음

---

**요약:**  
State 패턴은 객체의 상태에 따라 동작이 달라져야 하거나, 상태별 행동을 명확하게 분리하고 싶을 때 유용합니다.

## Strategy 패턴이 유용한 경우

- **여러 알고리즘(전략)을 동적으로 선택하거나 교체해야 할 때**
  - 실행 중에 다양한 알고리즘(정렬, 경로 탐색, 할인 정책 등)을 유연하게 바꿔야 할 때 유용합니다.
- **알고리즘을 클라이언트 코드와 분리하고 싶을 때**
  - 알고리즘을 별도의 클래스로 분리해, 클라이언트 코드의 복잡도를 낮추고 유지보수성을 높일 수 있습니다.
- **조건문(if-else, switch) 대신 전략 객체로 행동을 위임하고 싶을 때**
  - 다양한 조건에 따라 동작이 달라질 때, 조건문 대신 전략 객체를 사용해 코드의 가독성을 높일 수 있습니다.

---

### 예시

- **정렬, 필터링 등 다양한 알고리즘을 선택적으로 적용**
- **결제, 할인, 수수료 등 정책을 동적으로 변경**
- **게임 캐릭터의 움직임, AI 전략 등 동적 행동 변경**

---

### 장점

- 알고리즘(전략) 교체가 용이(유연성)
- 코드 중복 감소 및 조건문 제거
- 새로운 전략 추가가 쉬움(확장성)

---

### 단점

- 전략 클래스가 많아질 수 있음
- 클라이언트가 전략 선택을 직접 관리해야 할 수 있음

---

**요약:**  
Strategy 패턴은 다양한 알고리즘(전략)을 동적으로 선택하거나 교체해야 하거나, 알고리즘을 클라이언트 코드와 분리해 유연성과 확장성을 높이고 싶을 때 유용합니다.

## Template Method 패턴이 유용한 경우

- **알고리즘의 전체 구조(뼈대)는 동일하지만, 일부 단계(구현)는 다르게 해야 할 때**
  - 여러 클래스가 공통된 처리 절차를 따르되, 세부 단계만 다르게 구현해야 할 때 유용합니다.
- **코드 중복을 줄이고, 알고리즘의 일관성을 유지하고 싶을 때**
  - 알고리즘의 공통 부분을 상위 클래스에 두고, 변하는 부분만 하위 클래스에서 구현할 수 있습니다.
- **알고리즘의 일부 단계를 하위 클래스에서 선택적으로 오버라이드(재정의)할 수 있게 하고 싶을 때**
  - 후크 메서드(hook method)를 통해 하위 클래스가 필요에 따라 동작을 확장할 수 있습니다.

---

### 예시

- **문서 생성(파일 저장, 출력 등)에서 공통 절차와 개별 포맷 처리 분리**
- **게임의 턴 진행, AI 행동 등에서 공통 흐름과 개별 행동 분리**
- **데이터 처리 파이프라인(전처리, 처리, 후처리 등)에서 단계별 커스터마이즈**

---

### 장점

- 알고리즘의 구조(뼈대) 일관성 유지
- 코드 중복 감소 및 재사용성 향상
- 하위 클래스에서 필요한 부분만 오버라이드 가능(유연성)

---

### 단점

- 상속에 의존하므로, 클래스 수가 많아질 수 있음
- 하위 클래스가 많아지면 구조가 복잡해질 수 있음

---

**요약:**  
Template Method 패턴은 알고리즘의 전체 구조는 동일하지만, 일부 단계만 다르게 구현해야 할 때, 코드 중복을 줄이고 일관성을 유지하고 싶을 때 유용합니다.

## Visitor 패턴이 유용한 경우

- **객체 구조(트리, 복합 구조 등)는 변경하지 않고, 다양한 연산(기능)을 추가하고 싶을 때**
  - 기존 객체 구조를 수정하지 않고, 새로운 기능(연산)을 외부에서 쉽게 추가할 수 있습니다.
- **여러 종류의 객체에 대해 다양한 연산을 수행해야 할 때**
  - 각 객체별로 다른 동작이 필요할 때, Visitor를 통해 객체별 맞춤 연산을 구현할 수 있습니다.
- **객체 구조와 연산을 분리해, 유지보수성과 확장성을 높이고 싶을 때**
  - 연산(방문자)과 데이터 구조(요소)를 분리해, 각자의 변경이 독립적으로 가능해집니다.

---

### 예시

- **컴파일러의 구문 트리(문법 트리)에서 다양한 분석/변환/출력 작업**
- **파일 시스템, 문서 구조 등 트리 구조에서 통계, 출력, 변환 등 다양한 연산 추가**
- **그래픽 객체 집합에 대해 렌더링, 내보내기, 통계 등 다양한 기능 추가**

---

### 장점

- 객체 구조를 변경하지 않고 새로운 연산(기능) 추가 가능(확장성)
- 연산과 데이터 구조의 분리로 유지보수성 향상
- 복잡한 연산을 객체 외부에서 일관되게 구현 가능

---

### 단점

- 객체 구조가 자주 변경되면 Visitor 패턴 적용이 어려움
- 각 요소(객체)에 Visitor 수용 메서드(accept) 추가 필요
- 새로운 요소(객체) 추가가 번거로울 수 있음

---

**요약:**  
Visitor 패턴은 객체 구조는 그대로 두고, 다양한 연산(기능)을 외부에서 유연하게 추가하거나, 객체별로 다양한 동작이 필요할 때 유용합니다.

## Specification 패턴이 유용한 경우

- **비즈니스 규칙(검증, 조건 등)을 객체로 캡슐화해 재사용, 조합, 확장하고 싶을 때**
  - 복잡한 조건문(if-else, AND/OR 등)을 명확하게 분리해, 규칙을 객체로 관리할 수 있습니다.
- **여러 규칙을 동적으로 조합(AND, OR, NOT 등)하거나, 다양한 조합이 자주 바뀔 때**
  - 규칙 객체를 조합해 새로운 규칙을 쉽게 만들고, 변경에 유연하게 대응할 수 있습니다.
- **도메인 모델의 검증, 필터링, 검색 조건 등을 유연하게 관리하고 싶을 때**
  - 엔티티의 유효성 검사, 검색 조건, 정책 등 다양한 곳에 활용할 수 있습니다.

---

### 예시

- **사용자, 주문, 상품 등 도메인 객체의 유효성 검사/정책 적용**
- **검색/필터 조건을 동적으로 조합(AND/OR/NOT)하여 쿼리 생성**
- **복잡한 비즈니스 규칙을 객체로 분리해 관리**

---

### 장점

- 비즈니스 규칙의 재사용, 조합, 확장 용이
- 조건문(if-else) 감소로 코드 가독성/유지보수성 향상
- 규칙 변경/추가가 쉬움(유연성)

---

### 단점

- 규칙(스펙) 클래스가 많아질 수 있음
- 단순한 경우에는 구조가 복잡해질 수 있음

---

**요약:**  
Specification 패턴은 비즈니스 규칙(검증, 조건 등)을 객체로 캡슐화해 재사용, 조합, 확장하고 싶거나, 복잡한 조건을 명확하게 분리·관리하고 싶을 때 유용합니다.

## Iterator 패턴이 유용한 경우

- **컬렉션(집합, 리스트, 트리 등)의 내부 구조를 노출하지 않고, 요소를 순차적으로 접근하고 싶을 때**
  - 다양한 자료구조의 내부 구현에 상관없이, 동일한 방식으로 요소를 순회할 수 있습니다.
- **여러 종류의 컬렉션에 대해 일관된 순회 방법을 제공하고 싶을 때**
  - 배열, 리스트, 트리, 집합 등 다양한 컬렉션을 동일한 인터페이스로 순회할 수 있습니다.
- **컬렉션의 순회 방식을 유연하게 변경하거나, 여러 방식(정방향/역방향/필터 등)으로 순회하고 싶을 때**
  - 순회 로직을 컬렉션과 분리해, 다양한 순회 방법을 쉽게 추가할 수 있습니다.

---

### 예시

- **리스트, 트리, 그래프 등 다양한 자료구조의 요소 순회**
- **파일 시스템, 메뉴 구조 등 계층적 데이터의 순차적 접근**
- **필터링, 역방향, 조건부 등 다양한 순회 방식 구현**

---

### 장점

- 컬렉션의 내부 구조와 무관하게 일관된 순회 제공
- 순회 로직과 컬렉션 구조의 분리로 유지보수성 향상
- 다양한 순회 방식(정방향, 역방향, 필터 등) 확장 용이

---

### 단점

- 단순한 경우에는 오히려 구조가 복잡해질 수 있음
- 컬렉션/이터레이터 클래스가 많아질 수 있음

---

**요약:**  
Iterator 패턴은 컬렉션의 내부 구조를 노출하지 않고, 다양한 자료구조를 일관된 방식으로 순회하거나, 여러 순회 방식을 유연하게 제공하고 싶을 때 유용합니다.
